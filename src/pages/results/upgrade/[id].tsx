import { Head } from '@/components/Head'
import { MainWrapper } from '@/components/MainWrapper'
import CheckoutForm from '@/components/_results/CheckoutForm'
import { LoadingOverlayContext } from '@/contexts/LoadingOverlayContext'
import { PopUpContext } from '@/contexts/PopUpContext'
import { API } from '@/misc/API'
import { Constants } from '@/misc/Constants'
import { Paths } from '@/misc/Paths'
import { SQL } from '@/misc/SQL'
import { SQLQueries } from '@/misc/SQLQueries'
import { SQLResult } from '@/types/SQLTypes'
import { APIRes } from '@/types/misc'
import { getSession } from '@auth0/nextjs-auth0'
import { UserContext } from '@auth0/nextjs-auth0/client'
import { Button, Typography, useTheme } from '@mui/material'
import { Elements } from '@stripe/react-stripe-js'
import { loadStripe } from '@stripe/stripe-js'
import { db } from '@vercel/postgres'
import { GetServerSideProps } from 'next'
import { useContext, useState } from 'react'

if (!Constants.stripePublishableKey) {
  throw new Error('Missing environment variable for strip publishable key')
}
const stripePromise = loadStripe(Constants.stripePublishableKey)

export const getServerSideProps: GetServerSideProps<{}> = async ({ req, res, params }) => {
  let userID: string | undefined
  const testID = params?.id as string | undefined
  try {
    const session = await getSession(req, res)
    userID = session?.user.sub as string | undefined
  } catch (err) {}
  if (!userID || !testID) {
    return {
      redirect: {
        destination: Paths.notFound,
        permanent: false,
      },
    }
  }
  const client = await db.connect()
  const sqlRes = await SQL.query<SQLResult>(client, SQLQueries.doesTestExist(testID, userID))
  const row = !!sqlRes.res?.length ? sqlRes.res[0] : undefined
  if (!row?.result) {
    return {
      redirect: {
        destination: Paths.notFound,
        permanent: false,
        statusCode: '401',
      },
    }
  }
  client.release()
  return { props: {} }
}

export default function EnhanceResults() {
  const { palette } = useTheme()
  const { user, isLoading } = useContext(UserContext)
  const { pushPopUpMessage } = useContext(PopUpContext)
  const { toggle } = useContext(LoadingOverlayContext)
  const [clientSecret, setClientSecret] = useState<string | undefined>(undefined)

  const onUpgradeClick = async () => {
    let res: APIRes<string> | undefined
    let error: string | undefined
    toggle(true)
    try {
      res = await API.createPaymentIntent()
    } catch (err) {
      error = err as string
    }
    toggle(false)
    const secret = res?.res
    if (error || !secret) {
      return pushPopUpMessage({ message: error || Constants.unknownError, title: 'Error upgrading test', type: 'error' })
    }
    setClientSecret(secret)
  }

  return (
    <>
      <Head title="Get Full Results" description="Get access to deep understandings about your compatibility preferences" />
      <MainWrapper>
        <Typography variant="h2" style={{ padding: '50px 10px 30px 10px' }} textAlign={'center'}>
          Get the Complete Analysis
        </Typography>
        <div style={{ display: 'flex', justifyContent: 'center' }}>
          <div
            style={{
              padding: 20,
              border: `1px solid ${palette.divider}`,
              borderRadius: 10,
              width: '100%',
              maxWidth: 800,
              margin: 5,
              marginBottom: 40,
            }}
          >
            <Typography fontWeight={'bold'} variant="h5" textAlign={'center'}>
              Receive the next level of MBTI clarity with our highest tier of AI analysis!
            </Typography>
            <Typography variant="body1" padding={2}>
              You will receive a five page summary of your results generated by the most powerful OpenAI model on the market. Get precise,
              tailored answers for all your compatibility curiosity!
            </Typography>
            {clientSecret && (
              <Elements options={{ clientSecret, appearance: { theme: 'stripe' } }} stripe={stripePromise}>
                <CheckoutForm email={user?.email as string} />
              </Elements>
            )}
            {!clientSecret && (
              <Button variant="contained" fullWidth style={{ marginTop: 20 }} onClick={onUpgradeClick} disabled={!user || !!isLoading}>
                Upgrade Now
              </Button>
            )}
          </div>
        </div>
      </MainWrapper>
    </>
  )
}
